# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v_o9i6XlfJqGmUGKK-8hoXSeAQ1LrQ0x
"""

# derivacion numerica

# aproximar  diferencia progresiva para aproximar f(x)= ln(x), usando h = 0.1 , 0.005 , 0.001


import numpy as np
import matplotlib.pyplot as plt
import math 

f = lambda x: x**2

#funcion detemrinada
x1 = np.linspace(0, 14, 150)
y = f(x1)

#print(y)

h = 0.001

#calculo derivada

yPrima = (f(x1 + h) - f(x1)) /(h)

# grafica 
plt.plot(x1,y )
plt.plot(x1,yPrima)
plt.grid()

  

# https://realpython.com/python-lambda/

import numpy as np
import matplotlib.pyplot as plt
import math 

f = lambda x: x**2

#funcion detemrinada
x1 = np.linspace(0, 14, 150)
y = f(x1)

#print(y)

h = [0.1,0.05,0.01,0.005,0.001,0.0005,0.0001]

#calculo derivada

for dx in(h):
  yPrima = (f(x1 + dx) - f(x1)) /(dx)

import numpy as np
import matplotlib.pyplot as plt
import math 
import sympy as sp 

x = sp.Symbol('x')


expresion = x**2

#f = lambda x: expresion
f = sp.lambdify((x), expresion, "numpy")

#funcion detemrinada
x0 = 1.8    # centrado en un solo punto
y = f(x0)

#print(y)

h = [0.1,0.05,0.01,0.005,0.001,0.0005,0.0001]

#calculo derivada

a = []; b = [] # datos a ser tabulados
c = []
for dx in(h):
  yPrima = (f(x0 + dx) - f(x0)) /(dx)
  b.append(yPrima)

  a.append(f(x0 + dx) )
  
  c.append(abs(dx)/ (2* (x0**2)) )   #ver pag 175

print(a)
#determinar cotas de error

#sp.diff(yPrima,x)  # segunda derivada
ydosPrima = sp.diff(yPrima,x,2)
#ydosPrima = yPrima.diff(x0)

columna = []

# problema original tengo 3 arrays y quiero indexarlos columna a columna

for i in range(0,4): #representa las columnas
  if i == 0:
    for j in range(len(h)):
      elemento = h[j]
      columna.append(elemento)
      #np.transpose(columna)
  elif i == 1:
    for j in range(len(h)):
      elemento = a[j]
      columna.append(elemento)
  elif i == 2:
    for j in range(len(h)):
      elemento = b[j]
      columna.append(elemento)
  elif i == 3:
    for j in range(len(h)):
      elemento = c[j]
      columna.append(elemento)

print(columna)
matriz = []
numFilas = len(h)  ; numColumnas = 4
np.reshape(columna, (numFilas, numColumnas))

#for i in range(numFilas):
  #aa = []
  #for j in range(numColumnas):
  #  aa.append
  #matriz.append(aa)


    
 

#https://es.stackoverflow.com/questions/139141/evaluaci%C3%B3n-num%C3%A9rica-de-una-funci%C3%B3n-derivada 
#https://numpy.org/doc/stable/reference/generated/numpy.transpose.html
# https://numpy.org/doc/1.18/reference/generated/numpy.reshape.html  r

import numpy as np
h = [0.1,0.05,0.01,0.005,0.001,0.0005,0.0001]

# tarea ocnvertir la fila en columna