# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1o02xgSFqYBtG9cWtN7z1azYRVAFAfIhH
"""

#metodo de newton
from sympy import *
import random
import sys

def fprintf(stream, format_spec, *args):
    stream.write(format_spec % args)

def tabla(cantidadIteraciones,x0,xn1,error):
  x0    = str(x0)   #; x0    = eval(x0)  
  xn1   = str(xn1)  #; xn1   = eval(xn1)  
  error = str(error)#; error = eval(error)
  print(type(cantidadIteraciones),type(x0),type(xn1),type(error))
  fprintf(sys.stdout, "%i\t  %s\t %s\t %s ",cantidadIteraciones,x0,xn1,error )


a = 1 ; b = 2  # intervalo de la funcion 
random.seed(3)
x0 =  random.uniform(a, b)   #primer punto
x = symbols('x')
fx = lambda x : x**2 - 2     # funcion lambda arguments : expression
dfdx = fx(x).diff(x) # derivada  2x
# dfdx =  lambda x : fx(x).diff(x) 


f = fx(x0)                   # evaluar una funcion lambda respecto a valores iniciales
df = dfdx.evalf(x0)
#df = dfdx(x0) 

tolerancia = 1e-3 ; error = 1
cantidadIteraciones = 0      # el programa va a retornar la cantidad de pasos u operaciones se realizaron para ajustarse a la tolerancia deseada


while error > tolerancia:
  # el vlaor de f va a disminuir y se debe aproximar al f(xn) = 0 o odnde la funcion es cero
  # sin embargo ese cero no va ser exacto y va a estar detemrinaod por la tolerancia
  xn1 = x0 - (f / df)    # este va ser el nuevo punto 

  #f = fx(xn1);df = dfdx(xn1)  # reemplazo los valores por el metodo iterativo
  f =  fx(xn1) 
  df = sympify(dfdx).subs(x,xn1)#df = dfdx.evalf(xn1)
  
  

  error = abs((xn1 - x0)/(xn1)) 
  tabla(cantidadIteraciones,x0,xn1,error)
  
  x0 = xn1
  cantidadIteraciones += 1

print(cantidadIteraciones,xn1)